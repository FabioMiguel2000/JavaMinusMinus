PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< INTEGER : <DIGIT> (<DIGIT>)* > |
	< DIGIT : (["0" - "9"]) > |

	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_CURLY_BRACKET : "{"> |
	< CLOSE_CURLY_BRACKET : "}"> |
	< OPEN_SQUARE_BRACKET : "["> |
	< CLOSE_SQUARE_BRACKET : "]"> |
	< SEMICOLON : ";" > |
	< COMMA : "," > |
	< EQUALS : "=" > |
	< DOT : "." > |

	< AND_OP : "&&" > |
	< LESS_THAN : "<" > |
	< MORE_THAN : ">" > |
	< NOT_OP : "!" > |

	< TYPE_INT : "int"> |
	< TYPE_BOOL : "boolean"> |
	< TYPE_STRING : "String"> |

	< CLASS: "class"> |
	< IMPORT: "import"> |
	< EXTENDS: "extends" > |
	< PUBLIC: "public" > |
	< RETURN: "return" > |
	< STATIC: "static" > |
	< MAIN: "main" > |
	< VOID : "void" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< NEW : "new" > |
	< THIS : "this" > |
	< LENGTH : "length" > |

	< IDENTIFIER: ( <LETTER> | "$" | "_" )( <LETTER> | "$" | "_"  | <DIGIT>)* > |
	< LETTER : ( <LOWER_CASE> | <UPPER_CASE> ) > |
	< LOWER_CASE: ["a"-"z"] > | 
    < UPPER_CASE: ["A"-"Z"] > 
;

Program :
	(ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration:
	<IMPORT> <IDENTIFIER> (ImportDotDeclation)* <SEMICOLON>
;
ImportDotDeclation:
	<DOT> <IDENTIFIER> 
;

ClassDeclaration :
	(<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <OPEN_CURLY_BRACKET> (VarDeclaration)* (MethodDeclaration)* <CLOSE_CURLY_BRACKET>)
;

VarDeclaration :
 	( Type <IDENTIFIER> <SEMICOLON>  )
;	

MethodDeclaration :
	<PUBLIC>
	(SCAN 2 
	Type <IDENTIFIER> <OPEN_PAREN> 
		(Type <IDENTIFIER> ( <COMMA> Type <IDENTIFIER> )*)? 
	<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKET> 
		(SCAN 2 VarDeclaration | Statement)*
		<RETURN> Expression <SEMICOLON> 
	<CLOSE_CURLY_BRACKET>
	| 
	<STATIC> <VOID> <MAIN> <OPEN_PAREN> 
		Type <OPEN_SQUARE_BRACKET><CLOSE_SQUARE_BRACKET> <IDENTIFIER>
	<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKET> 
		(SCAN 2 VarDeclaration | Statement)* 
	<CLOSE_CURLY_BRACKET>)
;

Type :
	( <TYPE_INT> (<OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET>)? ) |
	( <TYPE_BOOL> ) |
	<TYPE_STRING> |
	<IDENTIFIER>
;

Statement :
	( <OPEN_CURLY_BRACKET> (Statement)* <CLOSE_CURLY_BRACKET> ) |
	( <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement ) |
	( <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement ) |
	( Expression (Assign)? <SEMICOLON> ) |
	( <IDENTIFIER> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> <EQUALS> Expression <SEMICOLON>  )
;

Assign:
	<EQUALS> Expression
;


Expression :
	AndExpression
;

AndExpression:
	LessThanExpression (<AND_OP> LessThanExpression)*
;

LessThanExpression:
	AdditiveExpression (<LESS_THAN> AdditiveExpression)*
;

AdditiveExpression:
	MultiplicativeExpression
	(
		(<PLUS> MultiplicativeExpression | <MINUS> MultiplicativeExpression)
	)*
;

MultiplicativeExpression:
	NotExpression
	(
		(<DIVIDE> NotExpression | <TIMES> NotExpression)
	)*
;

NotExpression:
	<NOT_OP> NotExpression | TerminalExpression
;

TerminalExpression:
	Factor (ArrayAccessExpression | MemberAcessExpression)*
;

ArrayAccessExpression:
	<OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>
;

MemberAcessExpression:
	<DOT>
	(
		<LENGTH> | (<IDENTIFIER> <OPEN_PAREN> (Expression (<COMMA> Expression)*)? <CLOSE_PAREN>)
	)
;

Factor:
	Literals |
	(<OPEN_PAREN> Expression <CLOSE_PAREN>) |
	ObjectCreationExpression
;

Literals:
	(<INTEGER>) |
	(<TRUE>) |
	(<FALSE>) |
	(<IDENTIFIER>) |
	(<THIS>) 
;

ObjectCreationExpression:
	<NEW>
	(
		<TYPE_INT> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> |
		<IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>
	)
;

INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }
    @Override
    public void add(JmmNode child, int index) {
        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }
    }
}