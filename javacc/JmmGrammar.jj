PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< DIGIT : (["0" - "9"]) > |
	< INTEGER : <DIGIT> (<DIGIT>)* > |

	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_CURLY_BRACKET : "{"> |
	< CLOSE_CURLY_BRACKET : "}"> |
	< OPEN_SQUARE_BRACKET : "["> |
	< CLOSE_SQUARE_BRACKET : "]"> |
	< SEMICOLON : ";" > |
	< COMMA : "," > |
	< EQUALS : "=" > |
	< DOT : "." > |

	< AND_OP : "&&" > |
	< LESS_THAN : "<" > |
	< MORE_THAN : ">" > |
	< NOT_OP : "!" > |

	< IDENTIFIER: ["a"-"z", "A"-"Z", "$", "_"](["a"-"z", "A"-"Z", "0"-"9", "$", "_"])*> |
	< LETTER : ( <LOWER_CASE> | <UPPER_CASE> ) > |
	< LOWER_CASE: ["a"-"z"] > | 
    < UPPER_CASE: ["A"-"Z"] > | 
	< UNDERSCORE: "_" > |
	
	< TYPE_INT : "int"> |
	< TYPE_BOOL : "boolean"> |
	< TYPE_STRING : "string"> |
	
	

	< IMPORT: "import"> |
	< CLASS: "class"> |
	< EXTENDS: "extends" > |
	< PUBLIC: "public" > |
	< RETURN: "return" > |
	< STATIC: "static" > |
	< MAIN: "main" > |
	< VOID : "void" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< NEW : "new" > |
	< THIS : "this" > |
	< LENGTH : "length" >
;

Program :
	(ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration:
	<IMPORT> <IDENTIFIER> (ImportDotDeclation)* <SEMICOLON>
;
ImportDotDeclation:
	<DOT> <IDENTIFIER> 
;

ClassDeclaration :
	(< CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)? < OPEN_CURLY_BRACKET > (VarDeclaration)* (MethodDeclaration)* < CLOSE_CURLY_BRACKET >)
;


VarDeclaration :
 	( Type <IDENTIFIER> <SEMICOLON>  )
;	

MethodDeclaration :
	(< PUBLIC > Type <IDENTIFIER> <OPEN_PAREN> (Type <IDENTIFIER> ( <COMMA> Type <IDENTIFIER> )*)? 
	<CLOSE_PAREN> <OPEN_CURLY_BRACKET> (VarDeclaration)? (Statement)? <RETURN> Expression <SEMICOLON> <CLOSE_CURLY_BRACKET>
	| <PUBLIC> <STATIC> <VOID> <MAIN> <OPEN_PAREN> <TYPE_STRING> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> 
	<IDENTIFIER> <CLOSE_PAREN> <OPEN_CURLY_BRACKET> (VarDeclaration)* (Statement)* <CLOSE_CURLY_BRACKET>)

;

Type :
	( <INTEGER> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> ) |
	( <TYPE_BOOL> ) |
	( <TYPE_INT> ) |
	<IDENTIFIER>
;

Statement :
	( <OPEN_CURLY_BRACKET> (Statement)* <CLOSE_CURLY_BRACKET> ) |
	( <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement ) |
	( <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement ) |
	( Expression <SEMICOLON> ) |
	( <IDENTIFIER> <EQUALS> Expression <SEMICOLON>  ) |
	( <IDENTIFIER> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> <EQUALS> Expression <SEMICOLON>  )
;


Expression :
	/*
	(Expression ((<AND_OP> | <LESS_THAN> | <PLUS> | <MINUS> | <TIMES> | <DIVIDE>) Expression)?)  |
	(Expression <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>) | 
	(Expression <DOT> <LENGTH>) |
	(Expression <DOT> <IDENTIFIER> <OPEN_PAREN> (Expression (<COMMA> Expression)*)?) <CLOSE_PAREN>|
	(<INTEGER>) |
	(<TRUE>) |
	(<FALSE>) |
	(<IDENTIFIER>) |
	(<THIS>) |
	(<NEW> <TYPE_INT> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>) |
	(<NEW> <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>) |
	(<NOT_OP> Expression) |
	(<OPEN_PAREN> Expression <CLOSE_PAREN>)
	*/
	AndExpression

;

AndExpression:
	LessThanExpression (<AND_OP> LessThanExpression)*
;

LessThanExpression:
	AdditiveExpression (<LESS_THAN> AdditiveExpression)*
;

AdditiveExpression:
	MultiplicativeExpression
	(
		(<PLUS> | <MINUS>)
		MultiplicativeExpression
	)*
;

MultiplicativeExpression:
	NotExpression
	(
		(<DIVIDE> | <TIMES>)
		NotExpression
	)*
;

NotExpression:
	<NOT_OP> NotExpression | TerminalExpression
;

TerminalExpression:
	Factor (ArrayAccessExpression | MemberAcessExpression)*
;

ArrayAccessExpression:
	<OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>
;

MemberAcessExpression:
	<DOT>
	(
		<LENGTH> | (<IDENTIFIER> <OPEN_PAREN> (Temp)? <CLOSE_PAREN>)
	)
;
Temp:
	Expression (<COMMA> Expression)*
;

Factor:
	Literals |
	(<OPEN_PAREN> Expression <CLOSE_PAREN>) |
	ObjectCreationExpression
;

Literals:
	(<INTEGER>) |
	(<TRUE>) |
	(<FALSE>) |
	(<IDENTIFIER>) |
	(<THIS>) 
	
;

ObjectCreationExpression:
	<NEW>
	(
		<TYPE_INT> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> |
		<IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>
	)
;

INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}