PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES = false;


SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< INTEGER : <DIGIT> (<DIGIT>)* > |
	< DIGIT : (["0" - "9"]) > |

	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_CURLY_BRACKET : "{"> |
	< CLOSE_CURLY_BRACKET : "}"> |
	< OPEN_SQUARE_BRACKET : "["> |
	< CLOSE_SQUARE_BRACKET : "]"> |
	< SEMICOLON : ";" > |
	< COMMA : "," > |
	< EQUALS : "=" > |
	< DOT : "." > |

	< AND_OP : "&&" > |
	< LESS_THAN : "<" > |
	< MORE_THAN : ">" > |
	< NOT_OP : "!" > |

	< TYPE_INT : "int"> |
	< TYPE_BOOL : "boolean"> |
	< TYPE_STRING : "String"> |

	< CLASS: "class"> |
	< IMPORT: "import"> |
	< EXTENDS: "extends" > |
	< PUBLIC: "public" > |
	< RETURN: "return" > |
	< STATIC: "static" > |
	< MAIN: "main" > |
	< VOID : "void" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< NEW : "new" > |
	< THIS : "this" > |
	< LENGTH : "length" > |

	< IDENTIFIER: ( <LETTER> | "$" | "_" )( <LETTER> | "$" | "_"  | <DIGIT>)* > |
	< LETTER : ( <LOWER_CASE> | <UPPER_CASE> ) > |
	< LOWER_CASE: ["a"-"z"] > | 
    < UPPER_CASE: ["A"-"Z"] > 
;

Program :
	(ImportDeclaration)* ClassDeclaration <EOF>
;

ImportDeclaration :
	<IMPORT> Id (ImportDotDeclation)* <SEMICOLON>
;

Id:
    <IDENTIFIER> ({jjtThis.put("name", lastConsumedToken.getImage()); }) 
;

ImportDotDeclation:
	<DOT> Id
;


ClassDeclaration: 
	(<CLASS> Id (ExtendsDeclation)?
	<OPEN_CURLY_BRACKET> 
		(VarDeclaration)* 
		(MethodTypes)* 
	<CLOSE_CURLY_BRACKET>)
;

ExtendsDeclation:
	<EXTENDS> Id
;

VarDeclaration:
 	( Type Id <SEMICOLON>   )
;	


MethodTypes #void:
	<PUBLIC>
	(
	MethodDeclaration
	| 
	MainMethodDeclaration 
	)
;

MethodDeclaration:
	
	(SCAN 2 
	MethodReturnType { jjtThis.put("returnType", lastConsumedToken.getImage()); }
	<IDENTIFIER> { jjtThis.put("name", lastConsumedToken.getImage()); }
	<OPEN_PAREN> 
		(FunctionParameters)?
	<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKET> 
		(SCAN 2 VarDeclaration | Statement)*
		ReturnDeclaration
	<CLOSE_CURLY_BRACKET>)
;
/*
MethodDeclaration2:
	<PUBLIC>
	(SCAN 2 
	<STATIC> { jjtThis.put("static", "true"); }

	MethodReturnType { jjtThis.put("returnType", lastConsumedToken.getImage()); }
	<IDENTIFIER> { jjtThis.put("name", lastConsumedToken.getImage()); }
	<OPEN_PAREN> 
		(FunctionParameters)?
	<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKET> 
		(SCAN 2 VarDeclaration | Statement)*
		ReturnDeclaration
	<CLOSE_CURLY_BRACKET>)
;*/

MethodReturnType #void:
	( <TYPE_INT>
	(<OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> )? ) |
	( <TYPE_BOOL> ) |
	<TYPE_STRING>  |
	<IDENTIFIER> 
;

FunctionParameters #void:
	( FunctionParameter ( <COMMA> FunctionParameter )*)
;

FunctionParameter:
	Type Id
;

ReturnDeclaration:
	<RETURN> Expression <SEMICOLON> 
;

MainMethodDeclaration:
	<STATIC> <VOID> <MAIN> { jjtThis.put("name", "static void main"); }
	<OPEN_PAREN> 
		MainMethodParameters
	<CLOSE_PAREN> 
	<OPEN_CURLY_BRACKET> 
		(SCAN 2 VarDeclaration | Statement)* 
	<CLOSE_CURLY_BRACKET>
;

MainMethodParameters:
	<TYPE_STRING> <OPEN_SQUARE_BRACKET><CLOSE_SQUARE_BRACKET> <IDENTIFIER> { jjtThis.put("name", "args[]"); }
;

Type:
	( <TYPE_INT> { jjtThis.put("type", lastConsumedToken.getImage()); }
	(<OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> { jjtThis.put("type", "int[]"); jjtThis.put("isArray", "true"); })? ) |
	( <TYPE_BOOL> ) { jjtThis.put("type", lastConsumedToken.getImage()); }|
	<TYPE_STRING>  { jjtThis.put("type", lastConsumedToken.getImage()); }|
	<IDENTIFIER> { jjtThis.put("type", lastConsumedToken.getImage());}
;

Statement #void:
	ScopeStatement |
	( IfElseStatement ) |
	( WhileStatement ) |
	Assign
;

ArrayAccess:
	<OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>
;

WhileStatement:
	<WHILE> <OPEN_PAREN> Expression #WhileCondition <CLOSE_PAREN> Statement
;

IfElseStatement:
	IfStatement ElseStatement
;
IfStatement:
	<IF> <OPEN_PAREN> Expression #IfCondition <CLOSE_PAREN> Statement
;
ElseStatement:
	<ELSE> Statement
;

ScopeStatement:
	( <OPEN_CURLY_BRACKET> (Statement)* <CLOSE_CURLY_BRACKET> )
;

Assign:
	(SCAN 2
	( Id (ArrayAccess)? <EQUALS> { jjtThis.put("value", "="); } Expression<SEMICOLON>) | (Expression <SEMICOLON>))
;


Expression #void:
	AndExpression 
;

AndExpression #void:
	LessThanExpression ((<AND_OP> LessThanExpression { jjtThis.put("value", "&&");}) #BinOp(2))* 
;

LessThanExpression #void:
	AdditiveExpression ((<LESS_THAN> AdditiveExpression { jjtThis.put("value", "<");}) #BinOp(2))*
;

AdditiveExpression #void:
	MultiplicativeExpression
	(
		( (<PLUS> MultiplicativeExpression) ({ jjtThis.put("op", "add"); }) #BinOp(2)) 
		| ((<MINUS> MultiplicativeExpression)({ jjtThis.put("op", "sub"); }) #BinOp(2))
	)*
;

MultiplicativeExpression #void:
	NotExpression
	(
		((<DIVIDE> NotExpression { jjtThis.put("op", "/"); })#BinOp(2) 
		| (<TIMES> NotExpression { jjtThis.put("op", "*"); })#BinOp(2))
	)*
;

NotExpression #void:
	(<NOT_OP> (NotExpression { jjtThis.put("value", "!"); })) #NotExpression | TerminalExpression
;

TerminalExpression #void:
	Factor (ArrayAccessExpression | MemberAcessExpression)*
;

ArrayAccessExpression #void:
	<OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> #ArrayAccessExpression(2) 
;

MemberAcessExpression #void:
	<DOT>
	(
		((<LENGTH> { jjtThis.put("value", ".length"); jjtThis.put("type", "int"); }) #LengthProperty(1)) | MethodCallExpression #CallExpression(2)
	)
;

MethodCallExpression: 
	(Id <OPEN_PAREN> ((Expression (<COMMA> Expression)*)? #Parameters) <CLOSE_PAREN>)
;

Factor #void:
	Literals |
	(<OPEN_PAREN> Expression <CLOSE_PAREN>) |
	ObjectCreationExpression
;

Literals #void:
	(<INTEGER> {jjtThis.put("type", "int"); jjtThis.put("value", lastConsumedToken.getImage()); } ) #Literal|
	(<TRUE> {jjtThis.put("type", "boolean"); jjtThis.put("value", lastConsumedToken.getImage()); }) #Literal|
	(<FALSE> {jjtThis.put("type", "boolean"); jjtThis.put("value", lastConsumedToken.getImage()); }) #Literal|
	(Id) |
	(<THIS> {jjtThis.put("type", "class"); jjtThis.put("value", lastConsumedToken.getImage()); }) #Literal 
;

ObjectCreationExpression:
	<NEW> {jjtThis.put("value", "new"); }
	(
		<TYPE_INT> ArrayDeclaration |
		Id <OPEN_PAREN> <CLOSE_PAREN>
	)
;

ArrayDeclaration:
	<OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> 
;

INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }
    @Override
    public void add(JmmNode child, int index) {
        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }
    }
}