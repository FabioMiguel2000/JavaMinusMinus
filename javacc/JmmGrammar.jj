PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< DIGIT : (["0" - "9"]) > |
	< INTEGER : <DIGIT> (<DIGIT>)* > |

	
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_CURLY_BRACKET : "{"> |
	< CLOSE_CURLY_BRACKET : "}"> |
	< OPEN_SQUARE_BRACKET : "["> |
	< CLOSE_SQUARE_BRACKET : "]"> |
	< SEMICOLON : ";" > |
	< COMMA : "," > |
	< EQUALS : "=" > |
	< DOT : "." > |

	< AND_OP : "&&" > |
	< LESS_THAN : "<" > |
	< MORE_THAN : ">" > |
	< NOT_OP : "!" > |

	< IDENTIFIER: (<LETTER> | <UNDERSCORE>) (<LETTER> | <UNDERSCORE> | <DIGIT>)* > |
	< LETTER : ( <LOWER_CASE> | <UPPER_CASE> ) > |
	< LOWER_CASE: ["a"-"z"] > | 
    < UPPER_CASE: ["A"-"Z"] > | 
	< UNDERSCORE: "_" > |
	
	< TYPE_INT : "int"> |
	< TYPE_BOOL : "boolean"> |
	< TYPE_STRING : "string"> |
	
	

	< IMPORT: "import"> |
	< CLASS: "class"> |
	< EXTENDS: "extends" > |
	< PUBLIC: "public" > |
	< RETURN: "return" > |
	< STATIC: "static" > |
	< MAIN: "main" > |
	< VOID : "void" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< NEW : "new" > |
	< THIS : "this" > |
	< LENGTH : "length" >
;
/*
Start : AdditiveExpression <EOF> ;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< INTEGER > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;
*/
Program :

	(ImportDeclaration)* ClassDeclaration < EOF >

;

ImportDeclaration :
	(< IMPORT > < IDENTIFIER > (< DOT > < IDENTIFIER >)* <SEMICOLON>)

;

ClassDeclaration :
	(< CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)? < OPEN_CURLY_BRACKET > (VarDeclaration)* (MethodDeclaration)* < CLOSE_CURLY_BRACKET >)
	
;


VarDeclaration :
 	( Type <IDENTIFIER> <SEMICOLON>  )
;	

MethodDeclaration :
	(< PUBLIC > Type <IDENTIFIER> <OPEN_PAREN> (Type <IDENTIFIER> ( <COMMA> Type <IDENTIFIER> )*)? 
	<CLOSE_PAREN> <OPEN_CURLY_BRACKET> (VarDeclaration)? (Statement)? <RETURN> Expression <SEMICOLON> <CLOSE_CURLY_BRACKET>
	| <PUBLIC> <STATIC> <VOID> <MAIN> <OPEN_PAREN> <TYPE_STRING> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> 
	<IDENTIFIER> <CLOSE_PAREN> <OPEN_CURLY_BRACKET> (VarDeclaration)* (Statement)* <CLOSE_CURLY_BRACKET>)

;

Type :
	( <INTEGER> <OPEN_SQUARE_BRACKET> <CLOSE_SQUARE_BRACKET> ) |
	( <TYPE_BOOL> ) |
	( <TYPE_INT> ) |
	<IDENTIFIER>
;

Statement :


	( <OPEN_CURLY_BRACKET> (Statement)* <CLOSE_CURLY_BRACKET> ) |
	( <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement ) |
	( <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement ) |
	( Expression <SEMICOLON> ) |
	( <IDENTIFIER> <EQUALS> Expression <SEMICOLON>  ) |
	( <IDENTIFIER> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET> <EQUALS> Expression <SEMICOLON>  )

;

Expression :

		(Expression ((<AND_OP> | <LESS_THAN> | <PLUS> | <MINUS> | <TIMES> | <DIVIDE>) Expression)?)  |
		(Expression <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>) |
		(Expression <DOT> <LENGTH>) |
		(Expression <DOT> <IDENTIFIER> <OPEN_PAREN> (Expression (<COMMA> Expression)*)?) <CLOSE_PAREN>|
		(<INTEGER>) |
		(<TRUE>) |
		(<FALSE>) |
		(<IDENTIFIER>) |
		(<THIS>) |
		(<NEW> <TYPE_INT> <OPEN_SQUARE_BRACKET> Expression <CLOSE_SQUARE_BRACKET>) |
		(<NEW> <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>) |
		(<NOT_OP> Expression) |
		(<OPEN_PAREN> Expression <CLOSE_PAREN>)

;

AndExpression:
	LessThanExpression (<AND_OP> LessThanExpression)?
;

LessThanExpression:
	PlusExpression (<LESS_THAN> PlusExpression)?
;

AdditiveExpression:
	MultiplicativeExpression
	(
		(<PLUS> | <MINUS>)
		MultiplicativeExpression
	)?
;


MultiplicativeExpression:
	NotExpression
	(
		(<DIVIDE> | <TIMES>)
		NotExpression
	)?
;

NotExpression:
	DotExpression | (<NOT_OP> DotExpression)
;

DotExpression:
	(ArrayExpression <DOT> <LENGTH>) |
	()
;

ArrayExpression:

;

Terminals:
	(<INTEGER>) |
	(<TRUE>) |
	(<FALSE>) |
	(<IDENTIFIER>) |
	(<THIS>) |
;




/*
PlusExpression:
	MinusExpression (<PLUS> MinusExpression)?
;


MinusExpression:
	TimesExpression (<MINUS> TimesExpression)?
;


TimesExpression:
	DivideExpression (<Times> DivideExpression)?
;


DivideExpression:
	NotExpression (<DivideExpression> NotExpression)?
;*/



